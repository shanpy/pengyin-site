<!DOCTYPE html>
<html prefix="og: http://ogp.me/ns# article: http://ogp.me/ns/article# " vocab="http://ogp.me/ns" lang="en">
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7" lang="en"> <![endif]--><!--[if (IE 7)&!(IEMobile)]><html class="no-js lt-ie9 lt-ie8" lang="en"><![endif]--><!--[if (IE 8)&!(IEMobile)]><html class="no-js lt-ie9" lang="en"><![endif]--><!--[if gt IE 8]><!--><!--<![endif]--><head>
<meta charset="utf-8">
<!-- http://t.co/dKP3o1e --><meta name="HandheldFriendly" content="True">
<meta name="MobileOptimized" content="320">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Reading Note - JavaScript Scoping, Hoisting and Others | Wendy's Corner</title>
<link href="../../../../assets/css/all.css" rel="stylesheet" type="text/css">
<!-- Webfonts --><link href="//fonts.googleapis.com/css?family=Lato:300,400,700,300italic,400italic" rel="stylesheet" type="text/css">
<!-- Load Modernizr --><script src="//mmistakes.github.io/hpstr-jekyll-theme/assets/js/vendor/modernizr-2.6.2.custom.min.js"></script><link rel="alternate" type="application/rss+xml" title="RSS" href="../../../../rss.xml">
<link rel="canonical" href="https://www.pengyin-shan.com/posts/2016/JavaScript/reading-note-javascript-scoping-hoisting-and-others/">
<link rel="icon" href="../../../../pengyin.ico" sizes="16x16">
<link rel="icon" href="../../../../pengyin.ico" sizes="128x128">
<!--[if lt IE 9]><script src="../../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Pengyin(Wendy) Shan">
<link rel="prev" href="../typescript-basics/" title="TypeScript Basics" type="text/html">
<link rel="next" href="../../Front%20End/learning-note-css-transitions-and-transforms/" title="Learning Note - CSS Transitions and Transforms (Lynda.com)" type="text/html">
<meta property="og:site_name" content="Wendy's Corner">
<meta property="og:title" content="Reading Note - JavaScript Scoping, Hoisting and Others">
<meta property="og:url" content="https://www.pengyin-shan.com/posts/2016/JavaScript/reading-note-javascript-scoping-hoisting-and-others/">
<meta property="og:description" content="During the process of learning TypeScript, I read an old blog article about JavaScript Scoping and Hoisting from Ben Cherry, and I like it. From this blog I go through more blog posts to extend my und">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2016-06-22T00:00:00-04:00">
<meta property="article:tag" content="JavaScript">
</head>
<body id="post-index" class="feature">
<a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    

    <nav id="dl-menu" class="dl-menuwrapper" role="navigation"><button class="dl-trigger">Open Menu</button>
    <ul class="dl-menu">
<li><a href="../../../">My Knowledge Base</a></li>
            <li><a href="https://www.linkedin.com/in/pengyinshan">My LinkedIn</a></li>
            <li><a href="../../../../categories/">Tags and Categories</a></li>
            <li><a href="../../../../rss.xml">RSS feed</a></li>
            <li><a href="../../../../archive.html">Archive</a></li>
    
    
    </ul></nav><div class="entry-header">
<!-- /.image-credit -->
    <div class="entry-image">
      <img src="../../../../bk.JPG" alt="Latest Posts">
</div>
<!-- /.entry-image -->
      
  <div class="header-title">
    <div class="header-title-wrap">
    <h1 id="brand"><a href="https://www.pengyin-shan.com/" title="Wendy's Corner" rel="home">
    Wendy's Corner</a></h1>
      <h2>Be Passionate.</h2>
    </div>
<!-- /.header-title-wrap -->
  </div>
<!-- /.header-title -->

</div>
<!-- /.entry-header -->

    <div id="main" role="main">
            
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><div class="entry-meta">
            <span class="dateline"><a href="." rel="bookmark"><time class="published dt-published" datetime="2016-06-22T00:00:00-04:00" itemprop="datePublished" title="2016-06-22">2016-06-22</time></a></span>
            <span class="byline author vcard">Pengyin(Wendy) Shan</span>
            <span>
        <ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../../categories/javascript/" rel="tag">JavaScript</a></li>
        </ul></span>
            <span style="font-style: italic;">
        <ul class="pager hidden-print">
<li class="previous">
                <a href="../typescript-basics/" rel="prev" title="TypeScript Basics">Previous post</a>
            </li>
            <li class="next">
                <a href="../../Front%20End/learning-note-css-transitions-and-transforms/" rel="next" title="Learning Note - CSS Transitions and Transforms (Lynda.com)">Next post</a>
            </li>
        </ul></span>
        </div>
        

    
    <h1 class="p-name entry-title" itemprop="headline name"><a href="." class="u-url">Reading Note - JavaScript Scoping, Hoisting and Others</a></h1>

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p>During the process of learning TypeScript, I read an old blog article about JavaScript Scoping and Hoisting from <a href="http://www.adequatelygood.com/about.html">Ben Cherry</a>, and I like it. From this blog I go through more blog posts to extend my understanding about JavaScript scoping, hoisting, prototype, etc. This is a study note for all of these knowledges.</p>
<h2 id="reference-list">Reference List</h2>
<ul>
<li>
<p><a href="http://www.adequatelygood.com/JavaScript-Scoping-and-Hoisting.html">JavaScript Scoping and Hoisting</a> by Ben Cherry</p>
</li>
<li>
<p><a href="http://developer.telerik.com/featured/seven-javascript-quirks-i-wish-id-known-about">Seven JavaScript Quirks I Wish I'd Known About</a> by Jim Cowart</p>
</li>
<li>
<p><a href="https://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/">Function Declarations vs. Function Expressions</a>by Angus Croll</p>
</li>
<li>
<p>(Chinese)<a href="http://www.jb51.net/article/75090.htm">Understanding JavaScript Scoping &amp; Hoisting (II)</a> by mdxy-dxy</p>
</li>
<li>
<p><a href="https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/">Everything you wanted to know about JavaScript scope</a> by Developer Advocate Telerik</p>
</li>
<li>
<p><a href="http://ryanmorr.com/understanding-scope-and-context-in-javascript/">Understanding Scope and Context in JavaScript</a> by Ryan Morr</p>
</li>
<li>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">Inheritance and the prototype chain</a> by MDN</p>
</li>
<li>
<p><a href="https://developers.google.com/speed/articles/optimizing-javascript">Optimizing JavaScript code</a> written by Gregory Baker, Software Engineer on GMail &amp; Erik Arvidsson, Software Engineer on Google Chrome</p>
</li>
<li>
<p><a href="https://www.toptal.com/javascript/javascript-prototypes-scopes-and-performance-what-you-need-to-know">JavaScript Prototype Chains, Scope Chains, and Performance: What You Need to Know</a> written by DIEGO CASTORINA</p>
</li>
</ul>
<h3 id="declarations-names-and-hoisting">Declarations, Names and Hoisting</h3>
<p>There is difference between declaring a variable and assigning value to a variable: <code>var x;</code> is declaration; <code>x = 1;</code> is assignment; <code>var x = 1;</code> is both declaring and assignment.</p>
<p>JavaScript has <code>function-level scope</code>, which mean <em>blocks does not create scope</em>.</p>
<p>From Ben, in JavaScript, a name enters a scope in four ways, with <strong>priority starting from top to bottom</strong>:</p>
<ol>
<li>
<p>Language-defined: i.e. <code>this</code> and <code>argument</code> keyword</p>
</li>
<li>
<p>Formal parameters: the parameters of function are scoped to the <em>body</em> of that function</p>
</li>
<li>
<p>Function declarations: as the form of <code>function foo(){}</code></p>
</li>
<li>
<p>Variable declarations: as the form of <code>var foo</code></p>
</li>
</ol>
<p><em>Above them, Function declarations and Variable declarations</em> are moved or <code>hoisted</code> to top of their <strong>containing scope</strong>. Two functions below are equivalent:</p>
<pre class="code literal-block"><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="kc">false</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">//Note assignment will not be hoisted</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
    <span class="nx">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>When a function expression is assigned to a declared variable, only this variable will be hoisted. The function body is left behind:</p>
<pre class="code literal-block"><span></span><span class="kd">function</span> <span class="nx">test</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">foo</span><span class="p">();</span> <span class="c1">// TypeError "foo is not a function"</span>
    <span class="nx">bar</span><span class="p">();</span> <span class="c1">// "this will run!"</span>
    <span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span> <span class="c1">// function expression assigned to local variable 'foo'</span>
        <span class="nx">alert</span><span class="p">(</span><span class="s2">"this won't run!"</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// function declaration, given the name 'bar'</span>
        <span class="nx">alert</span><span class="p">(</span><span class="s2">"this will run!"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">test</span><span class="p">();</span>
</pre>


<p>Angus Croll explained <code>return</code> statement also in his post:</p>
<ul>
<li>
<p>Code after the <code>return</code> statement is <strong>unreachable</strong>.</p>
</li>
<li>
<p>However, declarations contributes to its variable environment when <em>execution scope is entered</em>. <strong>They are distinct from Statements (such as <code>return</code>)</strong> and not subject to their rule of process.</p>
</li>
</ul>
<h3 id="function-declaration-function-expressions">Function Declaration &amp; Function Expressions</h3>
<p>Function can be declared (or actually not being declared) in different ways. Ben gave following example in his post:</p>
<pre class="code literal-block"><span></span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// TypeError "foo is not a function". The code below only hoists 'foo' variable, without function</span>
<span class="nx">bar</span><span class="p">();</span> <span class="c1">// valid. See code below</span>
<span class="nx">baz</span><span class="p">();</span> <span class="c1">// TypeError "baz is not a function"</span>
<span class="nx">spam</span><span class="p">();</span> <span class="c1">// ReferenceError "spam is not defined"</span>

<span class="kd">var</span> <span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{};</span> <span class="c1">// anonymous function expression ('foo' gets hoisted)</span>
<span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{};</span> <span class="c1">// function declaration ('bar' and the function body get hoisted)</span>
<span class="kd">var</span> <span class="nx">baz</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">spam</span><span class="p">()</span> <span class="p">{};</span> <span class="c1">// named function expression (only 'baz' gets hoisted)</span>

<span class="nx">foo</span><span class="p">();</span> <span class="c1">// valid</span>
<span class="nx">bar</span><span class="p">();</span> <span class="c1">// valid</span>
<span class="nx">baz</span><span class="p">();</span> <span class="c1">// valid</span>
<span class="nx">spam</span><span class="p">();</span> <span class="c1">// ReferenceError "spam is not defined"</span>
</pre>


<p>Another very good explanation is made by Angus Croll in his <a href="https://javascriptweblog.wordpress.com/2010/07/06/function-declarations-vs-function-expressions/">post</a>.</p>
<p><code>Function Declaration</code> defines a named function variable without requiring variable assignment. It must start with <code>function</code> keyword:</p>
<pre class="code literal-block"><span></span><span class="kd">function</span> <span class="nx">bar</span><span class="p">(){</span>
    <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<blockquote>
<p>For function declaration, the function name is visible within its own scope and scope of its parent.</p>
</blockquote>
<p><code>Function Expression</code> defines a function as part of a larger expression syntax (like a variable assignment). Function can be named or <code>anonymous</code>:</p>
<pre class="code literal-block"><span></span><span class="c1">//anonymous function expression</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//named function expression</span>
<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//self invoking function expression</span>
<span class="p">(</span><span class="kd">function</span> <span class="nx">sayHello</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">alert</span><span class="p">(</span><span class="s2">"hello!"</span><span class="p">);</span>
<span class="p">})();</span>
</pre>


<blockquote>
<p>For function expression, the function name is not visible outside of its own function scope</p>
</blockquote>
<p>He gave out following 4 questions as example:</p>
<p>Q1:</p>
<pre class="code literal-block"><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
    <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">bar</span><span class="p">();</span>
    <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">foo</span><span class="p">());</span>
<span class="c1">//8 is the answer</span>
</pre>


<p>Q2:</p>
<pre class="code literal-block"><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">bar</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">foo</span><span class="p">());</span>
<span class="c1">//3 is the answer</span>
</pre>


<p>Q3:</p>
<pre class="code literal-block"><span></span><span class="nx">alert</span><span class="p">(</span><span class="nx">foo</span><span class="p">());</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
    <span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="nx">bar</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="c1">//3 is the answer</span>
</pre>


<p>Q4:</p>
<pre class="code literal-block"><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
    <span class="k">return</span> <span class="nx">bar</span><span class="p">();</span>
    <span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">foo</span><span class="p">());</span>
<span class="c1">//[Type Error: bar is not a function] is the answer</span>
</pre>


<p>Based on theory above and <code>return</code> statement explanation, Q1 can be rewrite to:</p>
<pre class="code literal-block"><span></span><span class="c1">//**Simulated processing sequence for Question 1**</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
    <span class="c1">//define bar once</span>
    <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">//redefine it</span>
    <span class="kd">function</span> <span class="nx">bar</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">//Here bar() is rewrite</span>
    <span class="p">}</span>
    <span class="c1">//return its invocation</span>
    <span class="k">return</span> <span class="nx">bar</span><span class="p">();</span> <span class="c1">//8</span>
<span class="p">}</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">foo</span><span class="p">());</span>
</pre>


<p>Based on ECMA5, A variable with an <code>initialzier</code> is assigned the value of its Assignment Expression when the Variable Statement is <strong>executed</strong>, not when the variable is created. So Q2 can be rewrite to:</p>
<pre class="code literal-block"><span></span><span class="c1">//**Simulated processing sequence for Question 2**</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
    <span class="c1">//a declaration for each function expression</span>
    <span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="c1">//first Function Expression is executed</span>
    <span class="nx">bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="c1">// Function created by first Function Expression is invoked</span>
    <span class="k">return</span> <span class="nx">bar</span><span class="p">();</span>
    <span class="cm">/*</span>
<span class="cm">    second Function Expression unreachable because of return statement.</span>
<span class="cm">    Note second function expression itself cannot be hoisted,so it cannot pass return statement</span>
<span class="cm">    */</span><span class="o">*</span>
<span class="p">}</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">foo</span><span class="p">());</span> <span class="c1">//3</span>
</pre>


<p>Similarly, Q4 can be rewrite to:</p>
<pre class="code literal-block"><span></span><span class="c1">//**Simulated processing sequence for Question 4**</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
    <span class="c1">//a declaration for each function expression</span>
    <span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">bar</span> <span class="o">=</span> <span class="kc">undefined</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">bar</span><span class="p">();</span> <span class="c1">//TypeError: "bar not defined"</span>
    <span class="c1">//neither Function Expression is reached</span>
<span class="p">}</span>
<span class="nx">alert</span><span class="p">(</span><span class="nx">foo</span><span class="p">());</span>
</pre>


<h3 id="best-practice">Best Practice</h3>
<blockquote>
<p>Ben highly suggest having <em>exactly one</em> <code>var</code> statement per scope.</p>
</blockquote>
<p>Example:</p>
<pre class="code literal-block"><span></span><span class="cm">/*jslint onevar: true [...] */</span>
<span class="kd">function</span> <span class="nx">foo</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">,</span> <span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nx">bar</span><span class="p">,</span>
        <span class="nx">baz</span> <span class="o">=</span> <span class="s2">"something"</span><span class="p">;</span>
<span class="p">}</span>
</pre>


<p>Here is suggestion from ECMAScript Standard:</p>
<p><em><code>If the variable statement occurs inside a FunctionDeclaration, the variables are defined with function-local scope in that function, as described in section 10.1.3.</code> Otherwise, they are defined with global scope(that is, they are created as members of the global object, as described in section 10.1.3) using property attributes { DontDelete }. <code>Variables are created when the execution scope is entered. A Block does not define a new execution scope.</code> Only Program and FunctionDeclaration produce a new scope. Variables are initialized to undefined when created. <code>A variable with an Initializer is assigned the value of its AssignmentExpression when the VariableStatement is executed, not when the variable is created.</code></em></p>
<h2 id="scope-context-and-prototype">Scope, Context and Prototype</h2>
<h3 id="scope-context">Scope &amp; Context</h3>
<blockquote>
<p>Scope and Context are different.</p>
</blockquote>
<p>From <a href="http://ryanmorr.com/understanding-scope-and-context-in-javascript/">Ryan's blog post</a>, every function invocation has both a scope and a context associate with it. <strong>Scope is function-based and Context is object-based</strong>. Scope is depending on every time a function is invokes, while context is always <em>the value of <code>this</code> keyword</em> belonging to the object that <strong>owns the current executing code</strong>.</p>
<h3 id="scope">Scope</h3>
<p><a href="https://toddmotto.com/everything-you-wanted-to-know-about-javascript-scope/">Telerik</a> explained the usage of scope in detail.</p>
<h4 id="global-scope-local-scope">Global Scope &amp; Local Scope</h4>
<p>There is <code>Global Scope</code> and <code>Local Scope</code>.</p>
<p><code>Global Scope</code> is very useful for creating <code>namespace</code>, which is usually used to define highest level of scope. An exmaple is <code>jQuery('.myClass)</code>. <code>jQuery</code> is the namespace and in global scope.</p>
<p><code>Local Scope</code> is the scope besides global scope. Normal type is <code>Function scope</code>, which is existing in each function. Any locally scoped items are not visible in global scope. Example:</p>
<pre class="code literal-block"><span></span><span class="cm">/*</span>
<span class="cm">After applying hoisting rule, still 'name' is in local scope</span>
<span class="cm">*/</span>
<span class="kd">var</span> <span class="nx">myFunction</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">'Todd'</span><span class="p">;</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span> <span class="c1">// Todd</span>
<span class="p">};</span>
<span class="c1">// Uncaught ReferenceError: name is not defined</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
</pre>


<blockquote>
<p>a new scope is added to the scope chain when a <code>try-catch</code> block or a <code>with</code> block is encountered</p>
</blockquote>
<h4 id="scope-chain">Scope Chain</h4>
<p><code>Lexical Scope</code>: the inner function has access to the scope in outer function, but does not work backwards:</p>
<pre class="code literal-block"><span></span><span class="kd">var</span> <span class="nx">myFunction</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">name</span> <span class="o">=</span> <span class="s1">'Todd'</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">myOtherFunction</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">'My name is '</span> <span class="o">+</span> <span class="nx">name</span><span class="p">);</span>
  <span class="p">};</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">name</span><span class="p">);</span>
  <span class="nx">myOtherFunction</span><span class="p">();</span> <span class="c1">// call function</span>
<span class="p">};</span>

<span class="c1">// myFunction() will log out:</span>
<span class="c1">// `Todd`</span>
<span class="c1">// `My name is Todd`</span>
</pre>


<p><code>Scope Chain</code>: any function defined within another function has a local scope with <em>linked to the outer function</em>. This linking is the chain.</p>
<p>See graph from Diego Castorina below:</p>
<p>img-responsive images/articles/2016/javascript/scope_chain.png </p>
<blockquote>
<p>It’s always the position in the code that defines the scope. When resolving a variable, JavaScript starts at the innermost scope and searches outwards until it finds the variable/object/function it was looking for.</p>
</blockquote>
<p>By Ryan, for each <strong>execution context</strong> there is a scope chain coupled with it. The scope chain contains the objects for every execution context in the execution stack.</p>
<p>Example:</p>
<pre class="code literal-block"><span></span><span class="kd">function</span> <span class="nx">first</span><span class="p">(){</span>
    <span class="nx">second</span><span class="p">();</span>
    <span class="kd">function</span> <span class="nx">second</span><span class="p">(){</span>
        <span class="nx">third</span><span class="p">();</span>
        <span class="kd">function</span> <span class="nx">third</span><span class="p">(){</span>
            <span class="nx">fourth</span><span class="p">();</span>
            <span class="kd">function</span> <span class="nx">fourth</span><span class="p">(){</span>
                <span class="c1">// do something</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="nx">first</span><span class="p">();</span>
</pre>


<p>In the code above, the scope chain would be, from top to bottom: <code>fourth</code>, <code>third</code>, <code>second</code>, <code>first</code>, <code>global</code>.</p>
<ul>
<li>
<p>Naming Conflict: local variables with the same name as variables higher up the scope chain take precedence. So in code above, variables in <code>fourth</code> has highest priority if there is any naming conflict.</p>
</li>
<li>
<p>Look-up Process: if lacking of local variable, the look-up process will always <em>begin with its own variable object</em>. If the identifier is not found in the variable object, the search continues into the scope chain.</p>
</li>
</ul>
<p><code>Closure</code>: it is normally used in a <code>return</code> statement with function. This returned function itself is un-modified by any call to its outer function. However, A function doesn’t have to return in order to be called a closure though. Simply accessing variables outside of the immediate lexical scope creates a closure. Example:</p>
<pre class="code literal-block"><span></span><span class="kd">var</span> <span class="nx">sayHello</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">text</span> <span class="o">=</span> <span class="s1">'Hello, '</span> <span class="o">+</span> <span class="nx">name</span><span class="p">;</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">text</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">};</span>

<span class="nx">sayHello</span><span class="p">(</span><span class="s1">'Todd'</span><span class="p">);</span> <span class="c1">// nothing happens, no errors. Since a function is returned, an object is required to be assigned by this function</span>
<span class="kd">var</span> <span class="nx">helloTodd</span> <span class="o">=</span> <span class="nx">sayHello</span><span class="p">(</span><span class="s1">'Todd'</span><span class="p">);</span>
<span class="nx">helloTodd</span><span class="p">();</span> <span class="c1">// will call the closure and log 'Hello, Todd'</span>

<span class="nx">sayHello</span><span class="p">(</span><span class="s1">'Bob'</span><span class="p">)();</span>
<span class="cm">/*</span>
<span class="cm">Calls the returned function without assignment.</span>
<span class="cm">If any parameter required for inner function, this will become sayHello('Bob')('parameter')</span>
<span class="cm">*/</span><span class="o">*</span>
</pre>


<blockquote>
<p>Closure is significantly slower than creating an inner function without a closure, and mush slower than reusing a static function. Also closure is the most common resource for memory leaks.</p>
</blockquote>
<p>For example, for <code>setTimeout</code> function, following code is actually quickest:</p>
<pre class="code literal-block"><span></span><span class="kd">function</span> <span class="nx">alertMsg</span><span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">msg</span> <span class="o">=</span> <span class="s1">'Message to alert'</span><span class="p">;</span>
  <span class="nx">alert</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">setupAlertTimeout</span><span class="p">()</span> <span class="p">{</span>
  <span class="nb">window</span><span class="p">.</span><span class="nx">setTimeout</span><span class="p">(</span><span class="nx">alertMsg</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
<span class="p">}</span>
</pre>


<h4 id="private-and-public-scope">Private and Public Scope</h4>
<p>To create public/private environment in JavaScript, just like Java, <code>Closure</code> and <code>namespace</code> can be used.</p>
<p><strong>Wrapping functions inside function</strong> is a easy way to create private scope. In JavaScript, we need to wrap outer anonymous function in <code>()</code>, as following example:</p>
<pre class="code literal-block"><span></span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">myFunction</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="c1">// do some stuff here</span>
  <span class="p">};</span>
<span class="p">})();</span>

<span class="nx">myFunction</span><span class="p">();</span> <span class="c1">// Uncaught ReferenceError: myFunction is not defined</span>
</pre>


<p>To access the function in public but without modifying it, <code>Module Pattern</code> can be used. Declare a variable <code>module</code> using as a <strong>namespace</strong>, and assign a wrapped anonymous function to this variable. The anonymous function return a collection of attributes. Each attribute corresponds to a private function.</p>
<p>Example:</p>
<pre class="code literal-block"><span></span><span class="c1">// define module/namespace</span>
<span class="kd">var</span> <span class="nx">Module</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">myMethod</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="c1">//items inside this private function cannot be modified from outside</span>
    <span class="p">},</span>
    <span class="nx">someOtherMethod</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">})();</span>

<span class="c1">// call module + methods</span>
<span class="nx">Module</span><span class="p">.</span><span class="nx">myMethod</span><span class="p">();</span>
<span class="nx">Module</span><span class="p">.</span><span class="nx">someOtherMethod</span><span class="p">();</span>
</pre>


<p>To create <code>private methods</code>, which is the methods being used inside wrapping function but not from outside, create a local variable inside outer function, then assign the private method to it. Example:</p>
<pre class="code literal-block"><span></span><span class="kd">var</span> <span class="nx">Module</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">privateMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">publicMethod</span><span class="o">:</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
        <span class="c1">//private Method can be called here, but only publicMethod can be called from outside</span>
    <span class="p">}</span>
  <span class="p">};</span>
<span class="p">})();</span>
</pre>


<p>The code above can be written to <em>returning an object</em>:</p>
<pre class="code literal-block"><span></span><span class="kd">var</span> <span class="nx">Module</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">myModule</span> <span class="o">=</span> <span class="p">{};</span>
  <span class="kd">var</span> <span class="nx">privateMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
  <span class="nx">myModule</span><span class="p">.</span><span class="nx">publicMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
  <span class="nx">myModule</span><span class="p">.</span><span class="nx">anotherPublicMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
  <span class="k">return</span> <span class="nx">myModule</span><span class="p">;</span> <span class="c1">// returns the Object with public methods</span>
<span class="p">})();</span>

<span class="c1">// usage</span>
<span class="nx">Module</span><span class="p">.</span><span class="nx">publicMethod</span><span class="p">();</span>
</pre>


<blockquote>
<p>A good naming convention is to begin <code>private method</code> with an underscore<code>_</code></p>
</blockquote>
<p>Following is an example of returning an anonymous object, with attribute as each public method:</p>
<pre class="code literal-block"><span></span> <span class="kd">var</span> <span class="nx">Module</span> <span class="o">=</span> <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="kd">var</span> <span class="nx">_privateMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
  <span class="kd">var</span> <span class="nx">publicMethod</span> <span class="o">=</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>

  <span class="p">};</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">publicMethod</span><span class="o">:</span> <span class="nx">publicMethod</span><span class="p">,</span>
    <span class="nx">anotherPublicMethod</span><span class="o">:</span> <span class="nx">anotherPublicMethod</span>
  <span class="p">}</span>
<span class="p">})();</span>
</pre>


<h4 id="context-and-this">Context and <code>this</code>
</h4>
<p>When a function is called as a method of an object, <code>this</code> is set to the object <em>it is called on</em>:</p>
<pre class="code literal-block"><span></span><span class="kd">var</span> <span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nx">foo</span><span class="o">:</span> <span class="kd">function</span><span class="p">(){</span>
        <span class="nx">alert</span><span class="p">(</span><span class="k">this</span> <span class="o">===</span> <span class="nx">obj</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="nx">obj</span><span class="p">.</span><span class="nx">foo</span><span class="p">();</span> <span class="c1">// true</span>
</pre>


<p>When a <code>new</code> keyword is used to create new instance of an object, <code>this</code> is set to the newly-created instance:</p>
<pre class="code literal-block"><span></span><span class="kd">function</span> <span class="nx">foo</span><span class="p">(){</span>
    <span class="nx">alert</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">foo</span><span class="p">()</span> <span class="c1">// window</span>
<span class="k">new</span> <span class="nx">foo</span><span class="p">()</span> <span class="c1">// foo</span>
</pre>


<h4 id="execution-context">Execution Context</h4>
<blockquote>
<p>Execution Context refer more like a scope. It's not like the context discussed above.</p>
</blockquote>
<p>As Ryan stated, when the JavaScript interpreter initially executes code, it first enters to a <strong>global execution context</strong> by default.</p>
<p>Each time a new execution context is created it is appended to <strong>the top of the execution stack</strong>. The browser will always execute the current execution context that is at <em>top</em> of the execution stack. Once completed, it will be <em>removed</em> from the top of the stack and control will return to the execution context below.</p>
<p>An execution context can be divided into a <strong>creation</strong> and <strong>execution</strong> phase.</p>
<p>In the creation phase, the interpreter will first create a <code>variable object</code>(also called an <code>activation object</code>) that is composed of all the variables, function declarations, and arguments defined inside the execution context. From there the <code>scope chain</code> is <em>initialized</em> next, and the value of <code>this</code> is determined last.</p>
<p>Then in the execution phase, code is interpreted and executed.</p>
<h4 id="context-with-call-apply-and-bind">Context with <code>.call()</code>, <code>.apply()</code> and <code>.bind()</code>
</h4>
<p><code>call()</code>, <code>apply()</code> and <code>bind()</code> allow you to change function execution context.</p>
<p><code>my_function.call(scope, arg1, arg2, arg3)</code> requires arguments to be listed explicitly</p>
<p><code>my_function.apply(scope, [arg1, arg2])</code> allows array as to be parameter.</p>
<p><code>bind()</code> returns a new function which is <strong>permanently bound</strong> to the first argument of bind regardless of how the function is being used.</p>
<p>Example:</p>
<pre class="code literal-block"><span></span><span class="kd">var</span> <span class="nx">links</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelectorAll</span><span class="p">(</span><span class="s1">'nav li'</span><span class="p">);</span>
<span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="nx">links</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
  <span class="p">}).</span><span class="nx">call</span><span class="p">(</span><span class="nx">links</span><span class="p">[</span><span class="nx">i</span><span class="p">]);</span><span class="c1">//change this to be links[i]</span>
<span class="p">}</span>

<span class="nx">nav</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">'click'</span><span class="p">,</span> <span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
  <span class="nx">toggleNav</span><span class="p">(</span><span class="nx">arg1</span><span class="p">,</span> <span class="nx">arg2</span><span class="p">);</span>
<span class="p">},</span> <span class="kc">false</span><span class="p">);</span>
</pre>


<h3 id="inheritanceprototype-chain">Inheritance/Prototype Chain</h3>
<p>MDN has an <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">article</a> explaining Inheritance/Prototype Chain in detail.</p>
<blockquote>
<p>JavaScirpt is prototype-based. It is not class-based.</p>
</blockquote>
<h4 id="inheritance">Inheritance</h4>
<p><strong>Property Inheritance</strong></p>
<p>Before ES6, there is no <code>class</code> implementation. JavaScript only has one construct: <code>object</code>.</p>
<p>Each object has an <strong>internal link</strong> to another object called its <code>prototype</code>. This prototype object has <em>another prototype object of its own</em>. This link (prototype -&gt; prototype) continues <em>until an object is reached with <code>null</code> as its prototype</em>.</p>
<p><code>null</code> has no prototype. When reaching <code>null</code>, this marks the <strong>end</strong> of this <code>prototype chain</code>.</p>
<p>When trying to access a property of an object, original object is sought first. If no property found, this object's prototype will be searched. This process continues till the end of prototype chain is reached.</p>
<p>Use <code>object_name.[[Prototype]]</code> pattern to reach the prototype of <strong>object</strong>. <code>function_name.prototype</code> is used to reach all <code>instances</code> of this function.</p>
<blockquote>
<p>ES6 use <code>object_name.getPrototypeOf()</code> and <code>object_name.setPrototypeOf()</code> (getter&amp; setter) to access prototype.</p>
</blockquote>
<p>Example from MDN:</p>
<pre class="code literal-block"><span></span><span class="c1">// Let's assume we have object o, with its own properties a and b:</span>
<span class="c1">// {a: 1, b: 2}</span>
<span class="c1">// o.[[Prototype]] has properties b and c:</span>
<span class="c1">// {b: 3, c: 4}</span>
<span class="c1">// Finally, o.[[Prototype]].[[Prototype]] is null.</span>
<span class="c1">// This is the end of the prototype chain as null,</span>
<span class="c1">// by definition, null has no [[Prototype]].</span>
<span class="c1">// Thus, the full prototype chain looks like:</span>
<span class="c1">// {a:1, b:2} ---&gt; {b:3, c:4} ---&gt; null</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 1</span>
<span class="c1">// Is there an 'a' own property on o? Yes, and its value is 1.</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">b</span><span class="p">);</span> <span class="c1">// 2</span>
<span class="c1">// Is there a 'b' own property on o? Yes, and its value is 2.</span>
<span class="c1">// The prototype also has a 'b' property, but it's not visited.</span>
<span class="c1">// This is called "property shadowing"</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">c</span><span class="p">);</span> <span class="c1">// 4</span>
<span class="c1">// Is there a 'c' own property on o? No, check its prototype.</span>
<span class="c1">// Is there a 'c' own property on o.[[Prototype]]? Yes, its value is 4.</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">d</span><span class="p">);</span> <span class="c1">// undefined</span>
<span class="c1">// Is there a 'd' own property on o? No, check its prototype.</span>
<span class="c1">// Is there a 'd' own property on o.[[Prototype]]? No, check its prototype.</span>
<span class="c1">// o.[[Prototype]].[[Prototype]] is null, stop searching,</span>
<span class="c1">// no property found, return undefined</span>
</pre>


<p><strong>Method Inheritance</strong></p>
<p>In JavaScript, method inheritance is done by <em>adding function to be a property of an object</em>.</p>
<blockquote>
<p>When an inherited function is executed, the value of <code>this</code> points to the inheriting object, not to the prototype object where the function is an own property.</p>
</blockquote>
<p>Code Example:</p>
<pre class="code literal-block"><span></span><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">a</span><span class="o">:</span> <span class="mi">2</span><span class="p">,</span>
  <span class="nx">m</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">b</span><span class="p">){</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">m</span><span class="p">());</span> <span class="c1">// 3</span>
<span class="c1">// When calling o.m in this case, 'this' refers to o</span>

<span class="kd">var</span> <span class="nx">p</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">o</span><span class="p">);</span>
<span class="c1">// p is an object that inherits from o</span>

<span class="nx">p</span><span class="p">.</span><span class="nx">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span> <span class="c1">// creates an own property 'a' on p</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">m</span><span class="p">());</span> <span class="c1">// 13</span>
<span class="c1">// when p.m is called, 'this' refers to p.</span>
<span class="c1">// So when p inherits the function m of o,</span>
<span class="c1">// 'this.a' means p.a, the own property 'a' of p</span>
</pre>


<h4 id="create-object-with-prototype-chain">Create Object with Prototype Chain</h4>
<p>If a prototype chain is too long, it may has negative impact about code performance. Following rules are important to know:</p>
<ul>
<li>
<p>Remember to use <code>hasOwnProperty()</code> method to detect if this object has certain property on itself. <strong>This is the only method in JavaScript with dealing with prototype without traversing the whole prototype chain</strong>.</p>
</li>
<li>
<p>It is not enough to check whether a property is <code>undefined</code>. The property might very well exist, but its value just happens to be set to <code>undefined</code>.</p>
</li>
<li>
<p>Trying to access <em>nonexistent</em> properties will always traverse the <strong>full</strong> prototype chain.</p>
</li>
<li>
<p>If a object has instance A/B, and the prototype of this object change later, A and B's prototype of this object will also change. i.e. <code>Object.getPrototypeOf(a1).doSomething</code> == <code>Object.getPrototypeOf(a2).doSomething</code> == <code>A.prototype.doSomething</code>.</p>
</li>
<li>
<p><code>[[Prototype]]</code> is looked at <strong>recursively</strong>, i.e. <code>a1.doSomething</code>, <code>Object.getPrototypeOf(a1).doSomething</code>, <code>Object.getPrototypeOf(Object.getPrototypeOf(a1)).doSomething</code> etc., until it's found or <code>Object.getPrototypeOf</code> returns <code>null</code>.</p>
</li>
</ul>
<blockquote>
<p>In short, prototype is for types, while <code>Object.getPrototypeOf()</code> is the same for instances.</p>
</blockquote>
<p>When iterating over the properties of an object, every enumerable property that is on the prototype chain will be enumerated.</p>
<blockquote>
<p>It is a bad practice to extend <code>object.prototype</code>/<code>_proto_</code> or one of the other built-in prototypes. This is called <code>monkey</code> patching and breaks <code>encapsulation</code>.</p>
</blockquote>
<p>A graph from <a href="https://www.toptal.com/javascript/javascript-prototypes-scopes-and-performance-what-you-need-to-know">JavaScript Prototype Chains, Scope Chains, and Performance: What You Need to Know</a> written by DIEGO CASTORINA describe prototype chain very well:</p>
<p>img-responsive images/articles/2016/javascript/prototype_chain.png </p>
<p><strong>Simply Construct</strong></p>
<p>Code Example:</p>
<pre class="code literal-block"><span></span><span class="kd">var</span> <span class="nx">o</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span>

<span class="c1">// The newly created object o has Object.prototype as its [[Prototype]]</span>
<span class="c1">// o has no own property named 'hasOwnProperty'</span>
<span class="c1">// hasOwnProperty is an own property of Object.prototype.</span>
<span class="c1">// So o inherits hasOwnProperty from Object.prototype</span>
<span class="c1">// Object.prototype has null as its prototype.</span>
<span class="c1">// o ---&gt; Object.prototype ---&gt; null</span>

<span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"yo"</span><span class="p">,</span> <span class="s2">"whadup"</span><span class="p">,</span> <span class="s2">"?"</span><span class="p">];</span>

<span class="c1">// Arrays inherit from Array.prototype</span>
<span class="c1">// (which has methods like indexOf, forEach, etc.)</span>
<span class="c1">// The prototype chain looks like:</span>
<span class="c1">// a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null</span>

<span class="kd">function</span> <span class="nx">f</span><span class="p">(){</span>
  <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Functions inherit from Function.prototype</span>
<span class="c1">// (which has methods like call, bind, etc.)</span>
<span class="c1">// f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null</span>
</pre>


<p><strong>By <code>new</code> Keyword (Constructor)</strong></p>
<p>When an object is intialized by <code>new</code> keyword, it inherits all the properties in the prototype of that function. However, this object instance can not access <code>prototype</code> of its parent object directly. Instance can only acess its properties.</p>
<p>Code Example:</p>
<pre class="code literal-block"><span></span><span class="kd">function</span> <span class="nx">Graph</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">vertices</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">edges</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span>

<span class="nx">Graph</span><span class="p">.</span><span class="nx">prototype</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">addVertex</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">v</span><span class="p">){</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">vertices</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">v</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Graph</span><span class="p">();</span>
<span class="c1">// g is an object with own properties 'vertices' and 'edges'.</span>
<span class="c1">// g.[[Prototype]] is the value of Graph.prototype when new Graph() is executed.</span>
</pre>


<p>Another example:</p>
<pre class="code literal-block"><span></span><span class="c1">// Extending the Person prototype from our earlier example to</span>
<span class="c1">// also include a 'getFullName' method:</span>
<span class="nx">Person</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getFullName</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">firstName</span> <span class="o">+</span> <span class="s1">' '</span> <span class="o">+</span> <span class="k">this</span><span class="p">.</span><span class="nx">lastName</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Referencing the p1 object from our earlier example</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p1</span><span class="p">.</span><span class="nx">getFullName</span><span class="p">());</span>            <span class="c1">// prints 'John Doe'</span>
<span class="c1">// but p1 can’t directly access the 'prototype' object...</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p1</span><span class="p">.</span><span class="nx">prototype</span><span class="p">);</span>                <span class="c1">// prints 'undefined'</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">p1</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">getFullName</span><span class="p">());</span>  <span class="c1">// generates an error</span>
</pre>


<p>See graph example below:</p>
<p>img-responsive images/articles/2016/javascript/prototype_chain_2.png </p>
<p>Note: <code>var g = new Graph()</code> constructor above equals to following code:</p>
<pre class="code literal-block"><span></span><span class="kd">var</span> <span class="nx">g</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Object</span><span class="p">();</span>
<span class="nx">g</span><span class="p">.[[</span><span class="nx">Prototype</span><span class="p">]]</span> <span class="o">=</span> <span class="nx">Graph</span><span class="p">.</span><span class="nx">prototype</span><span class="p">;</span>
<span class="nx">Graph</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">g</span><span class="p">);</span>
</pre>


<p><strong>ES6: By <code>class</code> Keyword</strong></p>
<p>Code Example:</p>
<pre class="code literal-block"><span></span><span class="kd">var</span> <span class="nx">a</span> <span class="o">=</span> <span class="p">{</span><span class="nx">a</span><span class="o">:</span> <span class="mi">1</span><span class="p">};</span>
<span class="c1">// a ---&gt; Object.prototype ---&gt; null</span>

<span class="kd">var</span> <span class="nx">b</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">a</span><span class="p">);</span>
<span class="c1">// b ---&gt; a ---&gt; Object.prototype ---&gt; null</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">b</span><span class="p">.</span><span class="nx">a</span><span class="p">);</span> <span class="c1">// 1 (inherited)</span>

<span class="kd">var</span> <span class="nx">c</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="nx">b</span><span class="p">);</span>
<span class="c1">// c ---&gt; b ---&gt; a ---&gt; Object.prototype ---&gt; null</span>

<span class="kd">var</span> <span class="nx">d</span> <span class="o">=</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">create</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
<span class="c1">// d ---&gt; null</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">hasOwnProperty</span><span class="p">);</span>
<span class="c1">// undefined, because d doesn't inherit from Object.prototype</span>
</pre>


<h4 id="apply-prototype-as-best-practice">Apply Prototype as Best Practice</h4>
<p>From <a href="https://www.toptal.com/javascript/javascript-prototypes-scopes-and-performance-what-you-need-to-know">Diego Castorina</a>, prototype chain works as following:</p>
<ul>
<li>
<p>If the object has a property with the given name, that value is returned. (The <code>hasOwnProperty</code> method can be used to check if an object has a particular named property.)</p>
</li>
<li>
<p>If the object does not have the named property, the object’s prototype is checked</p>
</li>
<li>
<p>Since the prototype is an object as well, if it does not contain the property either, its parent’s prototype is checked.</p>
</li>
<li>
<p>This process continues up the prototype chain until the property is found.</p>
</li>
<li>
<p>If Object.prototype is reached and it does not have the property either, the property is considered <code>undefined</code>.</p>
</li>
</ul>
<p><strong>Constructor</strong></p>
<p>Gregory Baker write a article about<a href="https://developers.google.com/speed/articles/optimizing-javascript">Optimizing JavaScript code</a>. He mentioned <em>instead of</em> following constructor:</p>
<pre class="code literal-block"><span></span><span class="nx">baz</span><span class="p">.</span><span class="nx">Bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// constructor body</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// method body</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre>


<p>Using prototype is the <em>preferred</em> way of add attributes. In following code, no matter how many instances of <code>baz.Bar</code> are constructed, only a single function is ever created for <code>foo</code>, and no closures are created.</p>
<pre class="code literal-block"><span></span><span class="nx">baz</span><span class="p">.</span><span class="nx">Bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// constructor body</span>
<span class="p">};</span>

<span class="nx">baz</span><span class="p">.</span><span class="nx">Bar</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">foo</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// method body</span>
<span class="p">};</span>
</pre>


<p><strong>Initialize Instance</strong></p>
<p>Place instance variable declaration/initialization on the <code>prototype</code> for instance variables with <code>value type</code> (rather than reference type) initialization values (i.e. values of type <code>number</code>, <code>Boolean</code>, <code>null</code>, <code>undefined</code>, or <code>string</code>).  <em>This does not apply to initial value of parameters</em>.</p>
<p>Instead of following:</p>
<pre class="code literal-block"><span></span><span class="nx">foo</span><span class="p">.</span><span class="nx">Bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">prop1_</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">prop2_</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">prop3_</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">prop4_</span> <span class="o">=</span> <span class="s1">'blah'</span><span class="p">;</span>
<span class="p">};</span>
</pre>


<p>Use following:</p>
<pre class="code literal-block"><span></span><span class="nx">foo</span><span class="p">.</span><span class="nx">Bar</span> <span class="o">=</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">prop3_</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">};</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">Bar</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">prop1_</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">Bar</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">prop2_</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="nx">foo</span><span class="p">.</span><span class="nx">Bar</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">prop4_</span> <span class="o">=</span> <span class="s1">'blah'</span><span class="p">;</span>
</pre>
</div>

<div class="share">
    <span>
        <script src="//platform.linkedin.com/in.js" type="text/javascript"> lang: en_US</script><script type="IN/Share" data-url="https://www.pengyin-shan.com"></script></span>
    <span>
        <a href="https://twitter.com/share?ref_src=twsrc%5Etfw" class="twitter-share-button" data-show-count="false">Tweet</a><script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></span>
</div>


    </div>
        <section class="comments"><h2>Comments</h2>
        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="pengyinsnotes",
            disqus_url="https://www.pengyin-shan.com/posts/2016/JavaScript/reading-note-javascript-scoping-hoisting-and-others/",
        disqus_title="Reading Note - JavaScript Scoping, Hoisting and Others",
        disqus_identifier="cache/posts/2016/JavaScript/reading-note-javascript-scoping-hoisting-and-others.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section></article><script>var disqus_shortname="pengyinsnotes";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script>
</div>
    
    <div class="footer-wrapper">
        <footer role="contentinfo"><p>Contents © 2018         <a href="mailto:pengyin.shan@outlook.com">Pengyin(Wendy) Shan</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         </p>
            
        </footer>
</div>

    
    
    
    <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script><script src="../../../../assets/js/scripts.min.js"></script>
</body>
</html>
