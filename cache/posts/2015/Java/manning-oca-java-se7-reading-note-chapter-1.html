<p>This is a post that I moved from <a href="http://blogpengyin.herokuapp.com/">my old blog site</a>. This is the reading note for <strong>OCA Java SE 7 Certification Guide</strong> from <strong>Manning</strong>. <em>Please note that all definations and examples in this post are taken from the book.</em></p>
<h1 id="chapter-1-java-basics">Chapter 1: Java Basics</h1>
<p>Topics Covered in Chapter 1</p>
<blockquote>
<p>Understanding the structure and components of a Java class</p>
<p>Understanding executable Java applications</p>
<p>Understanding Java packages</p>
<p>Importing Java packages into your code</p>
<p>Applying access and nonaccess modifiers</p>
</blockquote>
<h2 id="11-the-structrue-of-a-java-class-and-source-code-file">1.1: The Structrue of a Java Class and Source Code File</h2>
<h3 id="111-struture-of-a-java-class">1.1.1 Struture of a Java Class</h3>
<p>Java source code file: xxx.<strong>java</strong>. A Java source code file (.java file) can define <strong>multiple classes and interfaces</strong>.</p>
<blockquote>
<p>in Java compiler: <strong>javac</strong> (.exe)</p>
<p>then output Java bytecode (compiled code for JVM): xxx.<strong>class</strong></p>
</blockquote>
<p><strong>List of Components in a class</strong></p>
<ul>
<li>
<p>The <strong>package</strong> statement</p>
</li>
<li>
<p>The <strong>import</strong> statement</p>
</li>
<li>
<p>Comments</p>
</li>
<li>
<p>Class declarations and definitions</p>
</li>
<li>
<p>Variables</p>
</li>
<li>
<p>Methods</p>
</li>
<li>
<p>Constructors</p>
</li>
</ul>
<p><strong>Package Statement</strong>
All Java classes are part of a package.</p>
<p>A Java class can be explicitly defined in a named package; otherwise it becomes part of a <strong>default package</strong>, which doesn’t have a name.</p>
<p>The package statement should be <strong>the first statement</strong> in a class.</p>
<p>The package statement cannot appear within a class declaration or after the class declaration.</p>
<p>The package statement must appear <strong>exactly once</strong> in a class.</p>
<p><strong>Import Statement</strong></p>
<p>Classes and interfaces in the same package can use each other without prefixing their names with the package name.</p>
<p>Code will fail compiling because an import statement can’t be placed before a package statement.</p>
<p>The <code>import</code> statement can’t be used to import <strong>multiple classes or interfaces with the same name</strong>.</p>
<p>If a class includes a <code>package</code> statement, all the <code>import</code> statements should follow the package statement.</p>
<p><strong>Comments</strong></p>
<p>Multiline comments span multiple lines of code. They start with <code>/*</code> and end with <code>*/</code>.</p>
<p>Multiline comments can contain any special characters (including Unicode characters).</p>
<p>People use an asterisk (<code>*</code>) to start the comment in the next line. Please note that this isn’t required—it’s done more for aesthetic reasons.</p>
<p>End-of-line comments start with <code>//</code> and, as evident by their name, they are placed at the end of a line of code.</p>
<p>A comment can precede a package statement.</p>
<p><strong>Class Declaration</strong></p>
<p>The class declaration marks the start of a class. It can be as simple as the keyword <code>class</code> followed by the name of a class.</p>
<p>The declaration of a class is composed of the following parts:</p>
<ul>
<li>
<p>Access modifiers</p>
</li>
<li>
<p>Nonaccess modifiers</p>
</li>
<li>
<p>Class name</p>
</li>
<li>
<p>Name of the <strong>base class</strong>, if the class is extending another class</p>
</li>
<li>
<p>All implemented <strong>interfaces</strong>, if the class is implementing any interfaces</p>
</li>
<li>
<p>Class body (class fields, methods, constructors), included within a pair of curly braces, <code>{}</code></p>
</li>
</ul>
<p>To declare a class, you must have:</p>
<ul>
<li>
<p>Keyword <code>class</code></p>
</li>
<li>
<p>Name of the class</p>
</li>
<li>
<p>Class body, marked by the opening and closing curly braces, {}</p>
</li>
<li>
<p>The <strong>property</strong> of an object: <code>variable</code></p>
</li>
<li>
<p>The <strong>behavior</strong> of an object: <code>method</code></p>
</li>
<li>
<p>The <strong>state</strong> of a class: <code>attribute</code> or <code>instance variable</code></p>
</li>
</ul>
<p>Points to remember:</p>
<blockquote>
<p>A class name <strong>starts</strong> with the keyword <code>class</code>. Watch out for the case of the keyword class. <strong>Java is case sEnSiTivE</strong>. class (lowercase c) isn’t the same as Class (uppercase C). <strong>You can’t use the word Class (capital C) to define a class</strong>.</p>
<p>The state of a class is defined using attributes or instance variables.</p>
<p>The behavior is defined using methods</p>
<p>A class definition may also include comments and constructors</p>
</blockquote>
<p>A class is a design from which an object can be created.</p>
<p><strong>Variables</strong></p>
<p>Variables that store the <strong>state</strong> of an object (also called an <strong>instance</strong>), they are called <code>instance variable</code>s or <code>instance attribute</code>s.</p>
<p>Each object has its own copy of the instance variables.</p>
<p>The instance variables are defined <strong>within a class</strong> but <strong>outside all methods</strong> in a class.</p>
<p>A class may define an <code>instance variable</code> <strong>before or after</strong> the definition of a <code>method</code> and still use it.</p>
<p>A single copy of a <code>class variable</code> or <code>static variable</code> is <strong>shared</strong> by all the objects of a class.</p>
<p><strong>Methods</strong></p>
<p><code>Instance method</code>s are generally used to manipulate the instance variables.</p>
<p>A <code>class method</code> or <code>static method</code> is used to work with the static variables.</p>
<p><strong>Constructors</strong></p>
<p>A <code>class constructor</code> is used to create and initialize the objects of a class.</p>
<p>A class can define <strong>multiple</strong> constructors that accept different sets of method parameters.</p>
<h3 id="112-structure-and-components-of-a-java-source-code-file">1.1.2 Structure and Components of a Java Source Code File</h3>
<p>A Java source code file is used to define classes and interfaces.</p>
<p>An <code>interface</code> is a grouping of related methods and constants, but the methods in an interface <strong>cannot define any implementation</strong>. An interface specifies a <strong>contract</strong> for the classes to implement.</p>
<p>The definition of an interface starts with the keyword <code>interface</code>. An interface can define <code>constant</code>s and <code>method</code>s. <strong>You can’t use the word Interface (with a capital I) to define an interface.</strong></p>
<p>You can also define a <strong>combination</strong> of classes and interfaces in the same Java source code file, in any order.</p>
<p>If you define a <code>public</code> class or an interface in a class, <strong>its name should match the name of the Java source code file</strong>. Also, a source code file <strong>can’t define more than one public class or interface</strong>.</p>
<p>When you use a package or import statement within such Java files, both the package and import statements apply to <strong>all of the classes and interfaces</strong> defined in that source code file.</p>
<p>Classes and interfaces defined in the same Java source code file <strong>can’t be defined in separate packages</strong>.</p>
<p>Classes and interfaces imported using the <code>import</code> statement are <strong>available to all the classes and interfaces</strong> defined in the same Java source code file.</p>
<h2 id="12-executable-java-applications">1.2 Executable Java Applications</h2>
<h3 id="121-executable-java-classes-versus-non-executable-java-classes">1.2.1 Executable Java Classes versus Non-executable Java Classes</h3>
<p>The <code>JVM</code> executes the code that is defined in the <code>main</code> method.</p>
<p>The <code>main</code> method should comply with the following rules:</p>
<ul>
<li>
<p>The method must be marked as a <code>public</code> method.</p>
</li>
<li>
<p>The method must be marked as a <code>static</code> method.</p>
</li>
<li>
<p>The name of the method must be <code>main</code>.</p>
</li>
<li>
<p>The return type of this method must be <code>void</code>.</p>
</li>
<li>
<p>The method must accept a method argument of a <code>String array</code> or a <code>variable argument</code> of type String. i.e. <code>String... args</code> and <code>String[] args</code> are all acceptable.</p>
</li>
</ul>
<p>To define a variable argument variable, the ellipsis (<code>...</code>) should follow the type of the variable and not the variable itself. i.e. <code>String args...</code> is <strong>not compiling</strong>.</p>
<p>To define an array, the square brackets, <code>[]</code>, can follow either the variable name or its type. i.e., <code>String[] args</code> and <code>String args[]</code> are all acceptable.</p>
<p>The placement of the keywords <code>public</code> and <code>static</code> can be <strong>interchanged</strong>. i.e. <code>public staic</code> and <code>static public</code> are all acceptable. <strong>You cannot move <code>void</code>!</strong></p>
<blockquote>
<p><strong>Important:</strong> As long as you do <code>java class_name_of_main (parameters)</code> in command line, you are calling <code>main</code> method. If you do <code>java name_of_other_class (parameters)</code>, you will be recogized as calling other methods.</p>
</blockquote>
<h2 id="13-java-packages">1.3 Java Packages</h2>
<p>If you don’t include an explicit package statement in a class or an interface, it’s part of a <code>default</code> package.</p>
<h3 id="132-defining-classes-in-a-package-using-the-package-statement">1.3.2 Defining classes in a package using the package statement</h3>
<p>It’s common for organiza- tions to use <strong>subpackages</strong> to define all their classes, such as <code>com.test.example</code>.</p>
<p>A few of important rules about packages:</p>
<ul>
<li>
<p>Per Java naming conventions, package names should all be in <strong>lowercase</strong>.</p>
</li>
<li>
<p>The package and subpackage names are separated using a dot (<code>.</code>).</p>
</li>
<li>
<p>Package names follow the rules defined for valid identifiers in Java.</p>
</li>
<li>
<p>For packaged classes and interfaces, the package statement is the <strong>first statement</strong> in a Java source file (a .java file). The exception is that comments can appear before or after a package statement.</p>
</li>
<li>
<p>There can be a <strong>maximum of one package</strong> statement per Java source code file(.java file).</p>
</li>
<li>
<p>All the classes and interfaces defined in a Java source code file will be defined in the same package. There is no way to package classes and interfaces defined within the same Java source code file in different packages.</p>
</li>
</ul>
<p>A <strong>fully qualified name</strong> for a class or interface is formed by prefixing its package name with its name (separated by a period), such as <code>packagename.Classname</code>.</p>
<p>To enable the Java Runtime Environment (<code>JRE</code>) to find your classes, add the base directory that contains your packaged Java code to the <strong>classpath</strong>.</p>
<h3 id="133-138">1.3.3 - 1.3.8</h3>
<p>Importing more classes doesn’t increase the size of your own class.</p>
<p>It is possible to use a packaged class or interface without using the import statement, by using its <strong>fully qualified name</strong>.</p>
<p>You can’t use the import statement to access multiple classes or interfaces with the <strong>same names from different packages</strong>. For example, you cannot import <code>java.util.Date</code> and <code>java.sql.Date</code> at the same time.</p>
<p>By using the wildcard character, an asterisk (<code>*</code>), you can import all of the public members, classes, and interfaces of a package. However, you can only use <code>*</code> to import <strong>current level class</strong>. You cannot import <strong>sub-level classes</strong>.</p>
<p>The <strong>default</strong> package is <strong>automatically imported</strong> in the Java classes and interfaces defined within the same directory on your system. However, <strong>A class from a default package can’t be used in any named packaged class</strong>, regardless of whether they are defined within the same directory or not.</p>
<p>You can import an individual <strong>static</strong> member of a class or all its static members by using the <code>import static</code> statement. <strong>Note correct statement is <code>import static</code>, not <code>static import</code>.</strong></p>
<h2 id="14-java-access-modifiers">1.4 Java Access Modifiers</h2>
<p>A <strong>top-level class</strong> is a class that isn’t defined within any other class. A class that is defined within another class is called a <strong>nested or inner class</strong>.</p>
<blockquote>
<p><strong>Important: Local variables</strong> and <strong>method parameters</strong> can’t be defined using access modifiers.</p>
</blockquote>
<p>Java defines four access modifiers:</p>
<ul>
<li>
<p><code>public</code> (least restrictive)</p>
</li>
<li>
<p><code>protected</code></p>
</li>
<li>
<p><code>default</code></p>
</li>
<li>
<p><code>private</code> (most restrictive)</p>
</li>
</ul>
<p>Think of Access Modifier from the following four perspectives:</p>
<ul>
<li>
<p>Same Package/Different Package</p>
</li>
<li>
<p>Derived Classes/Unrelated Classes</p>
</li>
</ul>
<p><code>Public</code>:</p>
<ul>
<li>
<p>The <strong>least restrictive</strong> access modifier.</p>
</li>
<li>
<p>Classes and interfaces defined using the public access modifier are accessible <strong>across all packages, from derived to unrelated classes</strong>.</p>
</li>
<li>
<p>All four perspeactives are avaiable.</p>
</li>
</ul>
<p><code>Proctected</code>:</p>
<p>The members of a class defined using the <code>protected</code> access modifier are accessible to:</p>
<ul>
<li>
<p>Classes and interfaces defined in the <strong>same package</strong></p>
</li>
<li>
<p><strong>All derived classes</strong>, even if they’re defined in separate packages</p>
</li>
<li>
<p>Only <em>unrelated/different package</em> perspective cannot access.</p>
</li>
<li>
<p>i.e. the subclass of derived class in different package cannot access.</p>
</li>
</ul>
<p><code>Default</code>:</p>
<ul>
<li>
<p>The members with <code>package access</code> are only accessible to classes and interfaces defined <strong>in the same package</strong>.</p>
</li>
<li>
<p>Only <em>same package</em> perspective get access.</p>
</li>
<li>
<p><code>Default</code> access can be compared to <em>package-private</em> (accessible only within a package) and <code>protected</code> access can be compared to <em>package- private + kids</em> (“kids” refer to derived classes)</p>
</li>
</ul>
<p><code>Private</code>:</p>
<ul>
<li>
<p>The members of a class defined using the <code>private</code> access modifier are accessible <strong>only to themselves</strong>.</p>
</li>
<li>
<p><strong>None of the four perspectives are accessiable</strong>.</p>
</li>
</ul>
<h2 id="15-nonaccess-modifiers">1.5 Nonaccess Modifiers</h2>
<p>]Access modifiers control the <strong>accessibility</strong> of your class and its members outside the class and the package.</p>
<p>Nonaccess modifiers change <strong>the default properties</strong> of a Java class and its members.</p>
<h3 id="151-abstract-modifier">1.5.1 Abstract Modifier</h3>
<p>Only <code>variable</code> cannot use <code>abstract</code>.</p>
<p><strong>An abstract <code>class</code> can’t be instantiated</strong>. i.e You cannot do <code>new abstract_class</code>.</p>
<p>An abstract class may or may not define an abstract method; <strong>you can define an abstract class without any abstract methods. But a concrete class can’t define an abstract method.</strong></p>
<p>An <code>interface</code> is an abstract entity <strong>by default</strong>.</p>
<p>You can add <code>abstract</code> keyword to interface if you like.</p>
<p>An abstract <code>method</code> doesn’t have a body.</p>
<p>Usually, an abstract method is implemented by a derived class.</p>
<p>A method with an empty body isn’t an abstract method. i.e. a method that havs <code>{}</code> is not a abstract method. a method that has <code>abstract</code> buy doesn't have <code>{}</code> is abstract method.</p>
<h3 id="152-final-modifier">1.5.2 Final Modifier</h3>
<p>Only <code>interface</code> cannot use <code>final</code></p>
<p>A class that is marked final <strong>cannot be extended</strong> by another class.</p>
<p>An <code>interface</code> cannot be marked as final.</p>
<p>A final <code>variable</code> can’t be reassigned a value. <strong>It can be assigned a value only once.</strong></p>
<p>You can call methods on a final variable, such as <code>a.append(b)</code>,assuming <code>b</code> is a final variable. But you cannot reassign another object to a final variable.</p>
<p>A final <code>method</code> defined in a base class <strong>can’t be overridden</strong> by a derived class.</p>
<h3 id="153-static-modifier">1.5.3 Static Modifier</h3>
<p>Variables, methods, classes and interfaces can all use <code>static</code> modifier.</p>
<p><code>static variables</code> belong to a class.</p>
<blockquote>
<p><code>static attributes</code> exist <strong>independently</strong> of any instances of a class and may be accessed even when no instances of the class have been created.</p>
<p>A <code>static variable</code> is shared by all of the objects of a class.**, i.e. if a instance change the value of a static variable, all instances that access this static variable after it will get same new value.</p>
<p>A <code>static variable</code> can be accessed using the name of the object
reference variable or the name of a class.</p>
<p>static method<code>s aren’t associated with objects and **can’t use any of the</code>instance variable`s of a class**.</p>
</blockquote>
<p>You can use static methods to define <code>utility method</code>s, which are methods that usually manipulate the method parameters to compute and return an appropriate value.</p>
<p>The static members aren’t involved in <strong>runtime polymorphism</strong>. <strong>You can’t override the static members in a derived class</strong>, but you can <strong>redefine</strong> them.</p>
<p><strong>Neither <code>static method</code>s nor <code>static variable</code>s can access the <code>non-static</code> variables and methods of a class.</strong> But <strong>the reverse is true</strong>: <code>non-static</code> variables and methods can access <code>static</code> variables and methods because the static members of a class exist even if no instances of the class exist.</p>
<blockquote>
<p>You can’t prefix the definition of a <strong>top-level</strong> class or an interface with the keyword <code>static</code>.</p>
</blockquote>